
import UIKit

// Copy-on-Write(以降、CoW)の仕組み


// MARK: - CoWの仕組み・動作

/*
 
 SwiftのArrayはCoWという仕組みを使用しており、
 書き込み時にコピーするといった挙動をする
 
 */

var a: [Int] = [0, 1, 2]
var b = a

/*
 
 上記のコードでは[0, 1, 2]を変数aに代入し、変数aを変数bに代入している
 当然だがprintすると、どちらも同じ値が代入されていることが分かる
 
 */

print(a) // [0, 1, 2]
print(b) // [0, 1, 2]

/*
 
 配列を表すバイト列はヒープ領域に格納され、
 代入された変数にはメモリアドレスが格納される
 
 つまり、変数a, 変数bはヒープ領域のどこかに格納された配列のインスタンスを参照している
 
 */

/*
 
 という事は、例えば変数aの値を変更すると
 変数bの値も変更するのかというと...変更されない
 
 */

a.append(100)

print(a) // [0, 1, 2, 100]
print(b) // [0, 1, 2]

/*
 
 変数a, 変数bはどちらも同じインスタンスを参照しているのにも関わらず、
 上記だと変数bの値は[0, 1, 2]のままである
 
 この仕組みを実現しているのが、CoWである
 
 この動作は、`append`を呼び出したタイミングでヒープ領域に格納された配列のバイト列がコピーされ、
 変数aと変数bには別々のメモリアドレスを参照することになる
 
 
 つまり、配列の値に変更を加えるまでは元の配列を共有し、
 配列の値を変更するときにのみ元の配列のコピーを生成する
 
 */

/*
 では、更に変数aに対して`append`して値を追加しようとする
 
 前の例でいけば、`append`する度に配列のバイト列がメモリにコピーされていく事になる
 */

a.append(90) // コピー？
a.append(100) // コピー？？
a.append(110) // コピー？？？

/*
 ただ、CoWは`append`する度にコピーが増えるといった仕組みにはなっていない
 
 なぜかというと、CoWのコピーを生成するには条件があって、
 値を変更前の変数a, 変数bのようにデータ領域が共有されていればコピーを生成する
 
 つまり、CoWは変更操作が生じて、かつデータ領域が他のオブジェクトに共有されていればコピーする仕組み
 
 なので、変更が加わる度にコピーが生成されているわけではない
 */

// MARK: - CoWの設計-データ領域の実装

// TODO: 実際にCoWを実装してみる


